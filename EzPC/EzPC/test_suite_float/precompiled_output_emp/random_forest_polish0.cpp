/*
This is an autogenerated file, generated using the EzPC compiler.
*/

#include "emp-sh2pc/emp-sh2pc.h" 
using namespace emp;
using namespace std;
int bitlen = 64;
int party,port;
char *ip = "127.0.0.1"; 
template<typename T> 
vector<T> make_vector(size_t size) { 
return std::vector<T>(size); 
} 

template <typename T, typename... Args> 
auto make_vector(size_t first, Args... sizes) 
{ 
auto inner = make_vector<T>(sizes...); 
return vector<decltype(inner)>(first, inner); 
} 

const uint32_t noOfFeatures =  (int32_t)64;

const uint32_t maxDepth =  (int32_t)11;

const int32_t maxDepthInt =  (int32_t)11;

const uint32_t noOfTrees =  (int32_t)5;

const uint32_t noOfNodes =  (int32_t)2048;

void accessElementOneD(auto& arr, Integer idx, auto& result){
result[ (int32_t)0] = Integer(bitlen,  (uint64_t)0, PUBLIC);

uint64_t ctr =  (uint64_t)0;
for (uint32_t i =  (int32_t)0; i < noOfFeatures; i++){

Integer r = Integer(bitlen, ctr, PUBLIC);

Integer t =  If(idx.operator==(r), arr[i], Integer(bitlen,  (uint64_t)0, PUBLIC));
result[ (int32_t)0] = result[ (int32_t)0].operator+(t);
ctr = (ctr +  (uint64_t)1);
}
}

void accessElementTwoD(auto& arr, int64_t treeId, Integer idx, auto& result, uint32_t start, uint32_t end){
result[ (int32_t)0] = Integer(bitlen,  (uint64_t)0, PUBLIC);

uint64_t ctr =  (uint64_t)0;

Integer idxcpy = idx;
for (uint32_t i = start; i < end; i++){
result[ (int32_t)0] = result[ (int32_t)0].operator+( If(idxcpy.operator==(Integer(bitlen, ctr, PUBLIC)), arr[treeId][i], Integer(bitlen,  (uint64_t)0, PUBLIC)));
ctr = (ctr +  (uint64_t)1);
}
}

uint32_t pow(uint32_t base, int32_t power){

uint32_t result =  (int32_t)1;
for (uint32_t i =  (int32_t)0; i < power; i++){
result = (result * base);
}
return result;
}

void infer(auto& modelFeatureChoice, auto& modelThresholdValue, auto& query, auto& result){

Integer currentIndex = Integer(bitlen,  (uint64_t)0, PUBLIC);

Integer leftOrRight = Integer(bitlen,  (uint64_t)0, PUBLIC);

auto currentSharedFeatureChoice = make_vector<Integer>( (int32_t)1);

auto currentSharedThreshold = make_vector<Integer>( (int32_t)1);

auto currentSharedQueryValue = make_vector<Integer>( (int32_t)1);
currentSharedFeatureChoice[ (int32_t)0] = Integer(bitlen,  (uint64_t)0, PUBLIC);
currentSharedThreshold[ (int32_t)0] = Integer(bitlen,  (uint64_t)0, PUBLIC);
currentSharedQueryValue[ (int32_t)0] = Integer(bitlen,  (uint64_t)0, PUBLIC);

uint32_t startIdx =  (int32_t)0;

uint32_t endIdx =  (int32_t)0;
for (uint32_t i =  (int32_t)0; i < noOfTrees; i++){
currentIndex = Integer(bitlen,  (uint64_t)0, PUBLIC);
currentSharedFeatureChoice[ (int32_t)0] = modelFeatureChoice[i][ (int32_t)0];
currentSharedThreshold[ (int32_t)0] = modelThresholdValue[i][ (int32_t)0];
accessElementOneD(query, currentSharedFeatureChoice[ (int32_t)0], currentSharedQueryValue);
leftOrRight =  If(currentSharedThreshold[ (int32_t)0].operator<(currentSharedQueryValue[ (int32_t)0]), Integer(bitlen,  (int64_t)1, PUBLIC), Integer(bitlen,  (int64_t)2, PUBLIC));
for (uint32_t j =  (int32_t)1; j < (maxDepthInt -  (int32_t)1); j++){
currentIndex = currentIndex.operator*(Integer(bitlen,  (uint64_t)2, PUBLIC)).operator+(leftOrRight);
startIdx = (pow( (uint32_t)2, j) -  (uint32_t)1);
endIdx = (pow( (uint32_t)2, (j +  (int32_t)1)) -  (uint32_t)1);
accessElementTwoD(modelThresholdValue, i, currentIndex, currentSharedThreshold, startIdx, endIdx);
accessElementTwoD(modelFeatureChoice, i, currentIndex, currentSharedFeatureChoice, startIdx, endIdx);
accessElementOneD(query, currentSharedFeatureChoice[ (int32_t)0], currentSharedQueryValue);
leftOrRight =  If(currentSharedThreshold[ (int32_t)0].operator<(currentSharedQueryValue[ (int32_t)0]), Integer(bitlen,  (int64_t)1, PUBLIC), Integer(bitlen,  (int64_t)2, PUBLIC));
}
currentIndex = currentIndex.operator*(Integer(bitlen,  (uint64_t)2, PUBLIC)).operator+(leftOrRight);
startIdx = (pow( (uint32_t)2, (maxDepthInt -  (int32_t)1)) -  (uint32_t)1);
endIdx = (pow( (uint32_t)2, maxDepthInt) -  (uint32_t)1);
accessElementTwoD(modelThresholdValue, i, currentIndex, currentSharedThreshold, startIdx, endIdx);
result[i] = currentSharedThreshold[ (int32_t)0];
}
}


int main(int argc, char** argv) {
parse_party_and_port(argv, &party, &port);
if(argc>3){
  ip=argv[3];
}
cout<<"Ip Address: "<<ip<<endl;
cout<<"Port: "<<port<<endl;
cout<<"Party: "<<(party==1? "CLIENT" : "SERVER")<<endl;
NetIO * io = new NetIO(party==ALICE ? nullptr : ip, port);
setup_semi_honest(io, party);


auto inferenceQuery = make_vector<Integer>(noOfFeatures);

auto modelFeatureChoice = make_vector<Integer>(noOfTrees, noOfNodes);

auto modelThresholdValue = make_vector<Integer>(noOfTrees, noOfNodes);

auto inferenceResult = make_vector<Integer>(noOfTrees);

Integer finalResult = Integer(bitlen,  (uint64_t)0, PUBLIC);
for (uint32_t i =  (int32_t)0; i < noOfFeatures; i++){
inferenceQuery[i] = Integer(bitlen,  (uint64_t)20, PUBLIC);
}
for (uint32_t i =  (int32_t)0; i < noOfTrees; i++){
for (uint32_t j =  (int32_t)0; j < noOfNodes; j++){
modelFeatureChoice[i][j] = Integer(bitlen, ((noOfNodes % noOfFeatures) +  (uint64_t)0), PUBLIC);
modelThresholdValue[i][j] = Integer(bitlen, (noOfNodes +  (uint64_t)351), PUBLIC);
}
}
infer(modelFeatureChoice, modelThresholdValue, inferenceQuery, inferenceResult);
for (uint32_t i =  (int32_t)0; i < noOfTrees; i++){
finalResult = finalResult.operator+(inferenceResult[i]);
}
cout << ("Value of finalResult:") << endl;
cout << (finalResult.reveal<uint64_t>(PUBLIC)) << endl;


finalize_semi_honest();
delete io; 
 
return 0;
}

